# Copyright 2018-2019 QuantumBlack Visual Analytics Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
# NONINFRINGEMENT. IN NO EVENT WILL THE LICENSOR OR OTHER CONTRIBUTORS
# BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# The QuantumBlack Visual Analytics Limited ("QuantumBlack") name and logo
# (either separately or in combination, "QuantumBlack Trademarks") are
# trademarks of QuantumBlack. The License does not grant you any right or
# license to the QuantumBlack Trademarks. You may not use the QuantumBlack
# Trademarks or any confusingly similar mark as a trademark for your product,
#     or use the QuantumBlack Trademarks in any other manner that might cause
# confusion in the marketplace, including but not limited to in advertising,
# on websites, or on software.
#
# See the License for the specific language governing permissions and
# limitations under the License.

"""``AbstractDataSet`` implementation to access Spark data frames using
``pyspark``
"""

import pickle
from typing import Any, Dict
import logging

from kedro.contrib.io import DefaultArgumentsMixIn
from kedro.io import AbstractVersionedDataSet, Version
from pyspark.sql import DataFrame

from datetime import datetime
from pyspark.sql.types import *

class SparkDataSet(DefaultArgumentsMixIn, AbstractVersionedDataSet):

    def _describe(self) -> Dict[str, Any]:
        return dict(
            filepath=self._filepath,
            file_format=self._file_format,
            load_args=self._load_args,
            save_args=self._save_args,
            version=self._version,
        )

    def __init__(  # pylint: disable=too-many-arguments
        self,
        filepath: str,
        file_format: str = "parquet",
        load_args: Dict[str, Any] = None,
        save_args: Dict[str, Any] = None,
        version: Version = None,
        credentials: Dict[str, Any] = None,
    ) -> None:
        """Creates a new instance of ``SparkDataSet``.

        Args:
            filepath: path to a Spark data frame.
            file_format: file format used during load and save
                operations. These are formats supported by the running
                SparkContext include parquet, csv. For a list of supported
                formats please refer to Apache Spark documentation at
                https://spark.apache.org/docs/latest/sql-programming-guide.html
            load_args: Load args passed to Spark DataFrameReader load method.
                It is dependent on the selected file format. You can find
                a list of read options for each supported format
                in Spark DataFrame read documentation:
                https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.DataFrame
            save_args: Save args passed to Spark DataFrame write options.
                Similar to load_args this is dependent on the selected file
                format. You can pass ``mode`` and ``partitionBy`` to specify
                your overwrite mode and partitioning respectively. You can find
                a list of options for each format in Spark DataFrame
                write documentation:
                https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.DataFrame
            version: If specified, should be an instance of
                ``kedro.io.core.Version``. If its ``load`` attribute is
                None, the latest version will be loaded. If its ``save``
                attribute is None, save version will be autogenerated.
            credentials: Credentials to access the S3 bucket, such as
                ``aws_access_key_id``, ``aws_secret_access_key``, if ``filepath``
                prefix is ``s3a://`` or ``s3n://``. Optional keyword arguments passed to
                ``hdfs.client.InsecureClient`` if ``filepath`` prefix is ``hdfs://``.
                Ignored otherwise.
        """

        super().__init__(
            load_args=load_args,
            save_args=save_args,
            filepath=filepath,
            version=version
        )

        self._file_format = file_format
        self._filepath = filepath



    def _load(self) -> DataFrame:
        base_path = self._filepath
        sitename = global_values.sitename.lower()
        interval = global_values.interval
        wind_mast_name = get_spark().sparkContext.getLocalProperty('wind_mast_name')
        start_date = datetime.strptime(global_values.start_date,"%Y-%m-%d")
        end_date = datetime.strptime(global_values.end_date, "%Y-%m-%d")
        aggregation_type = global_values.aggregation_type
        load_path = get_pathname(base_path, wind_mast_name,interval,sitename,start_date,end_date,aggregation_type)
        try:
            load_df = get_spark().read.load(load_path, self._file_format, **self._load_args)
        except:
            empty_schema = StructType([StructField("empty_col", StringType(), True)])
            load_df = get_spark().createDataFrame([],empty_schema)
        return load_df

    def _save(self, data: DataFrame) -> None:
        sitename = global_values.sitename.lower()

        base_path = self._filepath
        interval = int(global_values.interval)
        wind_mast_name = get_spark().sparkContext.getLocalProperty('wind_mast_name')
        start_date = datetime.strptime(global_values.start_date,"%Y-%m-%d")
        end_date = datetime.strptime(global_values.end_date, "%Y-%m-%d")
        aggregation_type = global_values.aggregation_type.lower()
        save_path = get_pathname(base_path, wind_mast_name,interval,sitename,start_date,end_date,aggregation_type)

        if not data.rdd.isEmpty():
            data.write.save(save_path, self._file_format, **self._save_args)
        else:
            logging.info('Empty dataset')

    def __getstate__(self):
        raise pickle.PicklingError("PySpark datasets can't be serialized")

